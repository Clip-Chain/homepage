<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <center><img src="Clip_Chain_Logo_New.png" width="500" height="200" alt="Clip Fusion Logo"></center>
  <title>Clip‑Fusion</title>
  <link rel="icon" type="image/x-icon" href="favichai.png">
  
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="https://www.youtube.com/iframe_api"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1415567035229271" crossorigin="anonymous"></script>
  <style>
    
    body.dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }
    body.dark-mode header,
    body.dark-mode main,
    body.dark-mode footer {
      background-color: #1e1e1e;
    }
    body.dark-mode .videoItem,
    body.dark-mode .categoryContainer {
      background-color: #2e2e2e;
      border-color: #444;
    }
    body.dark-mode textarea {
      background-color: #333;
      color: #fff;
      border: 1px solid #555;
    }
    body.dark-mode button {
      background-color: #444;
      color: #fff;
      border: 1px solid #555;
    }
    body.dark-mode #publisherContent,
    body.dark-mode #faq {
      background-color: #1e1e1e;
      border-color: #444;
    }
    
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1.6;
      color: #333;
    }
    header, main, footer {
      width: 100%;
      max-width: 1000px;
      padding: 20px;
      box-sizing: border-box;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      font-size: 2.5em;
      margin: 0;
    }
    h2, h3 {
      margin-top: 0;
    }
    textarea {
      width: 100%;
      max-width: 800px;
      margin: 10px auto;
      padding: 10px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      display: block;
    }
    
    .topButtons, .actionButtons, .playlistControls, .footerButtons {
      text-align: center;
      margin: 15px auto;
    }
    .topButtons button,
    .actionButtons button,
    .playlistControls button,
    .footerButtons button {
      padding: 10px 20px;
      background-color: #007bff;
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 1em;
      margin: 5px;
      border-radius: 5px;
    }
    .topButtons button:hover,
    .actionButtons button:hover,
    .playlistControls button:hover,
    .footerButtons button:hover {
      background-color: #0056b3;
    }
    
    .nav-bar {
      border-top: 2px solid #007bff;
      margin-bottom: 20px;
      padding: 10px 0;
      text-align: center;
      font-size: 1.2em;
    }
    .nav-bar a {
      color: #007bff;
      text-decoration: none;
      margin: 0 10px;
    }
    .nav-bar a:not(:last-child)::after {
      content: " |";
      margin-left: 10px;
      color: #007bff;
    }
    .nav-bar a.active {
      font-weight: bold;
    }
    
    #videoPlayerContainer {
      width: 100%;
      max-width: 640px;
      margin: 20px auto;
      position: relative;
      text-align: center;
      background-color: #000;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
    }
    #videoPlayerContainer.full {
      width: 100vw !important;
      height: 100vh !important;
      margin: 0 !important;
      padding: 0 !important;
      border-radius: 0 !important;
      max-width: none !important;
    }
    #videoPlayerContainer.full #videoPlayer,
    #videoPlayerContainer.full #youtubePlayerContainer {
      width: 100% !important;
      height: 100% !important;
    }
    #videoPlayerContainer.full #youtubePlayerContainer iframe {
      width: 100% !important;
      height: 100% !important;
    }
    #videoPlayer, #youtubePlayerContainer {
      width: 100%;
      height: 360px;
      background-color: #000;
      display: none;
      border-radius: 8px;
    }
    #emptyMessage {
      display: none;
      color: #ccc;
      font-size: 16px;
      padding: 20px;
      text-align: center;
    }
    
    .categoryContainer {
      width: 100%;
      max-width: 800px;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin: 15px auto;
      background-color: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .categoryHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .categoryHeader input.categoryTitle {
      font-size: 1.2em;
      font-weight: bold;
      padding: 5px;
      width: 70%;
    }
    .categoryHeader .categoryControls button {
      margin-left: 5px;
    }
    
    .videoItem {
      position: relative;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      padding: 10px;
      display: flex;
      align-items: center;
      border-radius: 8px;
      background-color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .videoItem .orderLabel {
      position: absolute;
      top: 5px;
      left: 5px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.8em;
    }
    .videoPreview, iframe.youtubePreview {
      width: 150px;
      height: 100px;
      margin-right: 10px;
      background-color: #000;
      border-radius: 8px;
      object-fit: cover;
    }
    .controls {
      display: flex;
      flex-direction: column;
      margin-left: 10px;
    }
    .timeInputs {
      display: flex;
      flex-direction: column;
      margin-top: 5px;
    }
    .timeInputs div {
      display: flex;
      gap: 5px;
      align-items: center;
      margin-bottom: 5px;
    }
    .timeInputs input {
      width: 50px;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    .actionButtons {
      text-align: center;
      margin: 15px 0;
    }
    .actionButtons button {
      padding: 10px 20px;
      background-color: #17a2b8;
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 1em;
      border-radius: 5px;
      margin: 5px;
    }
    .actionButtons button:hover {
      background-color: #138496;
    }
    .actionButtons button:active {
      background-color: #117a8b;
    }
    #publisherContent {
      max-width: 800px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    #faq {
      max-width: 800px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    #faq h2 {
      text-align: center;
    }
    .faq-item {
      margin-bottom: 20px;
    }
    .faq-item h3 {
      margin: 10px 0;
    }
    footer {
      text-align: center;
      margin-top: 30px;
      padding: 20px;
      border: none;
    }
    .footerButtons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .footerButtons button {
      padding: 10px 20px;
      margin: 5px;
      background-color: #007bff;
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 1em;
      border-radius: 5px;
    }
    .footerButtons button:hover {
      background-color: #0056b3;
    }
    @media (max-width: 600px) {
  header, main, footer {
    padding: 10px;
    width: 100%;
  }
  h1 {
    font-size: 1.8em;
  }
  h2, h3 {
    font-size: 1.2em;
  }
  .topButtons button,
  .actionButtons button,
  .footerButtons button {
    font-size: 0.9em;
    padding: 8px 16px;
  }
  .videoItem {
    flex-direction: column;
    align-items: center;
  }
  .videoPreview, iframe.youtubePreview {
    width: 100%;
    height: auto;
    margin-right: 0;
    margin-bottom: 10px;
  }
  #videoPlayer, #youtubePlayerContainer {
    height: auto;
  }
  img {
    max-width: 100%;
    height: auto;
  }
}
  </style>
</head>
<body>
  <header>
    <div class="nav-bar">
      <a href="index.html" class="nav-button">Clip‑Chain</a>
      <a href="Clip-Fusion.html" class="nav-button active">Clip‑Fusion</a>
    </div>
    <button id="darkModeToggle" style="position: fixed; top: 10px; right: 10px;">Dark Mode</button>
    <h1>Clip‑Fusion - Multi‑Category Video Playlist Generator</h1>
  </header>

  <main>
    
    <div id="categoriesContainer"></div>

    
    <div class="topButtons">
      <button id="addCategoryButton">Add Category</button>
      <button id="shuffleCategoriesButton">Shuffle Categories</button>
      <button id="downloadAllButton">Download All Categories as TXT</button>
      <button id="importAllTxtButton">Import TXT files</button>
      <button id="globalFolderImportBtn">Upload Local Folder (TXT+Videos)</button>
      
      <input type="file" id="globalTxtInput" accept=".txt" style="display:none;" multiple>
      <input type="file" id="globalFolderInput" webkitdirectory style="display:none;">
    </div>

    
    <div class="topButtons">
      <button id="generatePlaylistButton">Play Playlist</button>
      <button id="shuffleVideosButton">Shuffle Videos in Categories</button>
    </div>

    
    <div id="videoPlayerContainer">
      <video id="videoPlayer" controls autoplay></video>
      <div id="youtubePlayerContainer"></div>
      <div id="emptyMessage">No videos in the playlist. Please add videos and press "Play Playlist"!</div>
    </div>

    
    <div class="playlistControls" style="display: none; justify-content: center; gap: 10px;">
      <button id="prevButton"><< Previous Video</button>
      <button id="restartButton">Restart Playlist</button>
      <button id="nextButton">Next Video >></button>
      <button id="fullscreenButton">Full Screen</button>
      <button id="hideUIButton">Minimal UI</button>
    </div>

    
    <section id="publisherContent">
      <center><h1><b>How to Use Clip‑Fusion</b></h1></center>
      <p><b>Step 1:</b> For each category, enter a title and paste the video URLs (one per line). To group multiple videos for one round, separate the URLs with “&&”. Use the format: [link], [start time], [end time]. If only one timestamp is given, it is treated as the start time (end defaults to “00:00:00”).</p>
      <p><b>Step 2:</b> Videos are automatically parsed and previewed as you type. You can adjust timestamps, reorder, or remove videos using the buttons beside each preview.</p>
      <p><b>Step 3:</b> When you press “Play Playlist,” Clip‑Fusion plays one group (round) from each category in a round‑robin fashion. If a category’s list ends, it loops back to the beginning.</p>
      <p><b>Tip:</b> Download each category’s text (including the title and current timestamps) individually or all categories at once using the download buttons.</p>
      <center><h2>Welcome to Clip‑Fusion</h2></center>
      <p>Clip‑Fusion lets you organize videos into categories with grouped rounds and automatic round‑robin playback. Enjoy features like shuffling categories and videos, local file uploads, and full control over timestamps.</p>
    </section>

    <section id="faq">
      <h2>Frequently Asked Questions</h2>
      <div class="faq-item">
        <h3>How do I group multiple videos for one round?</h3>
        <p>Type the video URLs on a single line and separate them with “&&”. They will play together in the same round in the order listed.</p>
      </div>
      <div class="faq-item">
        <h3>How are timestamps handled?</h3>
        <p>If you change a timestamp manually (or provide only an end timestamp), the download will include them. A lone end timestamp is output as “00:00:00, [end]”.</p>
      </div>
      <div class="faq-item">
        <h3>How do next/previous controls work with grouped videos?</h3>
        <p>Next/Previous buttons navigate within the current group. Pressing Previous on the first video goes to the last video of the previous group; pressing Next on the last video goes to the first video of the next group. At the very beginning or end, it wraps around.</p>
      </div>
    </section>
  </main>

  <footer>
    <div class="footerButtons">
      <a href="about.html"><button>About</button></a>
      <a href="terms.html"><button>Terms Of Service</button></a>
      <a href="privacy.html"><button>Privacy Policy</button></a>
      <a href="contact.html"><button>Contact us</button></a>
    </div>
  </footer>


  <script>
    
    let categories = [];
    let globalPlaylist = [];  
    let currentGlobalIndex = 0;
    let currentGroupVideoIndex = 0;
    let hls = null;
    
    let youtubePlayer = null;
    let minimalMode = false;
    let ytPollInterval = null;
    
    let importCatCounter = 0;

    
    function createTimeDiv(timeStr, onChangeCallback) {
      const div = document.createElement('div');
      const placeholders = ['HH', 'MM', 'SS'];
      let values = ['', '', ''];
      if (timeStr && timeStr.includes(':')) {
        values = timeStr.split(':');
        while (values.length < 3) { values.push(''); }
      }
      placeholders.forEach((placeholder, i) => {
        const input = document.createElement('input');
        input.type = 'number';
        input.placeholder = placeholder;
        if (placeholder === 'SS') { input.step = "any"; }
        if (values[i]) { input.value = values[i]; }
        if(onChangeCallback) {
          input.addEventListener('change', onChangeCallback);
        }
        div.appendChild(input);
      });
      return div;
    }
    function getTimeString(container) {
      const inputs = container.getElementsByTagName('input');
      const parts = [];
      for (let i = 0; i < inputs.length; i++) {
        let val = inputs[i].value.trim();
        if (val === '') { val = '00'; }
        if (val.length < 2) { val = '0' + val; }
        parts.push(val);
      }
      return parts.join(':');
    }
    function calculateSeconds(timeDiv) {
      const [hh, mm, ss] = [...timeDiv.children].map(input => {
        const value = parseFloat(input.value);
        return isNaN(value) ? 0 : value;
      });
      return hh * 3600 + mm * 60 + ss;
    }
    function extractYouTubeId(url) {
      const match = url.match(/(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=))([\w-]+)/);
      return match ? match[1] : null;
    }

    
    function updateCategoryRawText(cat) {
      let lines = [];
      cat.groups.forEach(group => {
        let parts = group.map(video => {
          let start = getTimeString(video.startTimeDiv);
          let end = getTimeString(video.endTimeDiv);
          if(start !== "00:00:00" || end !== "00:00:00"){
            return video.link + ", " + start + ", " + end;
          } else {
            return video.link;
          }
        });
        lines.push(parts.join(" && "));
      });
      cat.rawText = lines.join("\n");
      const textarea = document.getElementById("textarea_" + cat.id);
      if(textarea) { 
        textarea.value = cat.rawText; 
      }
    }

    
    function parseCategory(cat) {
      cat.groups = [];
      const lines = (cat.rawText || "").trim().split('\n').filter(l => l.trim() !== "");
      lines.forEach(line => {
        const tokens = line.split("&&").map(t => t.trim());
        const group = [];
        tokens.forEach(token => {
          const parts = token.split(',');
          const link = parts[0].trim();
          let start = parts.length === 2 ? parts[1].trim() : (parts.length >=3 ? parts[1].trim() : "00:00:00");
          let end = parts.length >= 3 ? parts[2].trim() : "00:00:00";
          const video = {
            link: link,
            startTimeDiv: createTimeDiv(start, () => { updateCategoryRawText(cat); }),
            endTimeDiv: createTimeDiv(end, () => { updateCategoryRawText(cat); }),
            startTime: 0,
            endTime: 0
          };
          group.push(video);
        });
        if(group.length > 0) cat.groups.push(group);
      });
    }
    function renderCategories() {
      const container = document.getElementById('categoriesContainer');
      container.innerHTML = "";
      categories.forEach((cat, index) => {
        const catDiv = document.createElement('div');
        catDiv.classList.add('categoryContainer');
        catDiv.setAttribute('data-id', cat.id);
        const headerDiv = document.createElement('div');
        headerDiv.classList.add('categoryHeader');
        const titleInput = document.createElement('input');
        titleInput.type = 'text';
        titleInput.classList.add('categoryTitle');
        titleInput.value = cat.title;
        titleInput.addEventListener('input', function () {
          cat.title = this.value;
        });
        headerDiv.appendChild(titleInput);
        const controlsDiv = document.createElement('div');
        controlsDiv.classList.add('categoryControls');
        const upBtn = document.createElement('button');
        upBtn.textContent = "▲";
        upBtn.title = "Move Category Up";
        upBtn.disabled = index === 0;
        upBtn.addEventListener('click', () => {
          if(index > 0) {
            [categories[index-1], categories[index]] = [categories[index], categories[index-1]];
            renderCategories();
          }
        });
        controlsDiv.appendChild(upBtn);
        const downBtn = document.createElement('button');
        downBtn.textContent = "▼";
        downBtn.title = "Move Category Down";
        downBtn.disabled = index === categories.length - 1;
        downBtn.addEventListener('click', () => {
          if(index < categories.length - 1) {
            [categories[index], categories[index+1]] = [categories[index+1], categories[index]];
            renderCategories();
          }
        });
        controlsDiv.appendChild(downBtn);
        const removeBtn = document.createElement('button');
        removeBtn.textContent = "Remove Category";
        removeBtn.addEventListener('click', () => {
          categories.splice(index, 1);
          renderCategories();
        });
        controlsDiv.appendChild(removeBtn);
        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = "Download Category TXT";
        downloadBtn.addEventListener('click', () => {
          downloadCategory(cat);
        });
        controlsDiv.appendChild(downloadBtn);
        
        const importTxtBtn = document.createElement('button');
        importTxtBtn.textContent = "Import TXT file";
        importTxtBtn.addEventListener('click', () => {
          cat.txtFileInput.click();
        });
        controlsDiv.appendChild(importTxtBtn);
        
        const uploadFolderBtn = document.createElement('button');
        uploadFolderBtn.textContent = "Upload local folder (TXT+Videos)";
        uploadFolderBtn.addEventListener('click', () => {
          cat.folderInput.click();
        });
        controlsDiv.appendChild(uploadFolderBtn);
        const shuffleCatBtn = document.createElement('button');
        shuffleCatBtn.textContent = "Shuffle Videos";
        shuffleCatBtn.addEventListener('click', () => {
          if(cat.groups && cat.groups.length > 1) {
            for(let i = cat.groups.length - 1; i > 0; i--){
              const j = Math.floor(Math.random() * (i + 1));
              [cat.groups[i], cat.groups[j]] = [cat.groups[j], cat.groups[i]];
            }
            renderCategoryVideos(cat.id);
          }
        });
        controlsDiv.appendChild(shuffleCatBtn);
        headerDiv.appendChild(controlsDiv);
        catDiv.appendChild(headerDiv);
        const textarea = document.createElement('textarea');
        textarea.id = "textarea_" + cat.id;
        textarea.placeholder = "Paste video links here. To group videos for one round, separate URLs with '&&'. Format: [link], [start time], [end time].";
        textarea.value = cat.rawText || "";
        textarea.addEventListener('input', function () {
          cat.rawText = this.value;
          parseCategory(cat);
          renderCategoryVideos(cat.id);
        });
        catDiv.appendChild(textarea);
        const btnDiv = document.createElement('div');
        btnDiv.classList.add('topButtons');
        const uploadBtn = document.createElement('button');
        uploadBtn.textContent = "Upload Local Video";
        uploadBtn.addEventListener('click', () => {
          cat.fileInput.click();
        });
        btnDiv.appendChild(uploadBtn);
        catDiv.appendChild(btnDiv);
        const videoListContainer = document.createElement('div');
        videoListContainer.classList.add('videoListContainer');
        videoListContainer.id = "videoList_" + cat.id;
        catDiv.appendChild(videoListContainer);
        const fileInput = document.createElement('input');
        fileInput.type = "file";
        fileInput.accept = "video/mp4, video/webm, video/avi, video/mpeg, video/mkv, video/flv, video/ogg, video/mov, video/m4v, video/wmv, video/asf, video/3gp";
        fileInput.multiple = true;
        fileInput.style.display = "none";
        fileInput.addEventListener('change', function(event) {
          const files = event.target.files;
          let currentText = textarea.value.trim();
          for(let i = 0; i < files.length; i++){
            const file = files[i];
            const fileURL = URL.createObjectURL(file);
            currentText += (currentText ? "\n" : "") + fileURL;
          }
          textarea.value = currentText;
          cat.rawText = currentText;
          parseCategory(cat);
          renderCategoryVideos(cat.id);
        });
        cat.fileInput = fileInput;
        catDiv.appendChild(fileInput);
        
        const txtInput = document.createElement('input');
        txtInput.type = "file";
        txtInput.accept = ".txt";
        txtInput.style.display = "none";
        txtInput.addEventListener('change', function(event) {
          const file = event.target.files[0];
          if(file){
            const reader = new FileReader();
            reader.onload = function(e) {
              const content = e.target.result;
              const lines = content.split("\n");
              if(lines[0].startsWith("Title:")){
                cat.title = lines[0].substring(6).trim();
                const titleInput = catDiv.querySelector("input.categoryTitle");
                if(titleInput) titleInput.value = cat.title;
                lines.shift();
              }
              cat.rawText = lines.join("\n");
              textarea.value = cat.rawText;
              parseCategory(cat);
              renderCategoryVideos(cat.id);
            };
            reader.readAsText(file);
          }
        });
        cat.txtFileInput = txtInput;
        catDiv.appendChild(txtInput);
        
        const folderInput = document.createElement('input');
        folderInput.type = "file";
        folderInput.setAttribute("webkitdirectory", "");
        folderInput.style.display = "none";
        folderInput.addEventListener('change', function(event) {
          const files = Array.from(event.target.files);
          
          const txtFiles = files.filter(f => f.name.toLowerCase().endsWith('.txt'));
          if(txtFiles.length === 0){
            alert("No TXT file found in folder.");
            return;
          }
          
          const txtFile = txtFiles[0];
          
          const videoMapping = {};
          files.forEach(f => {
            if(!f.name.toLowerCase().endsWith('.txt')){
              videoMapping[f.name] = URL.createObjectURL(f);
            }
          });
          const reader = new FileReader();
          reader.onload = function(e) {
            let content = e.target.result;
            
            const lines = content.split("\n").map(line => {
              const tokens = line.split(",");
              const newTokens = tokens.map(tok => {
                const ttrim = tok.trim();
                return videoMapping[ttrim] ? videoMapping[ttrim] : ttrim;
              });
              return newTokens.join(", ");
            });
            content = lines.join("\n");
            if(content.startsWith("Title:")){
              
              const contentLines = content.split("\n");
              cat.title = contentLines[0].substring(6).trim();
              const titleInput = catDiv.querySelector("input.categoryTitle");
              if(titleInput) titleInput.value = cat.title;
              contentLines.shift();
              content = contentLines.join("\n");
            }
            cat.rawText = content;
            textarea.value = cat.rawText;
            parseCategory(cat);
            renderCategoryVideos(cat.id);
          };
          reader.readAsText(txtFile);
        });
        cat.folderInput = folderInput;
        catDiv.appendChild(folderInput);
        container.appendChild(catDiv);
        parseCategory(cat);
        renderCategoryVideos(cat.id);
      });
    }
    function renderCategoryVideos(catId) {
      const cat = categories.find(c => c.id === catId);
      if(!cat) return;
      const container = document.getElementById("videoList_" + catId);
      container.innerHTML = "";
      if(!cat.groups || cat.groups.length === 0) {
        container.textContent = "No videos added yet.";
        return;
      }
      cat.groups.forEach((group, gIndex) => {
        const groupDiv = document.createElement('div');
        groupDiv.classList.add('videoItem');
        const controlDiv = document.createElement('div');
        controlDiv.classList.add('reorderButtons');
        const upButton = document.createElement('button');
        upButton.innerHTML = "▲";
        upButton.title = "Move Group Up";
        upButton.disabled = gIndex === 0;
        upButton.addEventListener('click', () => {
          if(gIndex > 0) {
            [cat.groups[gIndex - 1], cat.groups[gIndex]] = [cat.groups[gIndex], cat.groups[gIndex - 1]];
            renderCategoryVideos(cat.id);
          }
        });
        controlDiv.appendChild(upButton);
        const downButton = document.createElement('button');
        downButton.innerHTML = "▼";
        downButton.title = "Move Group Down";
        downButton.disabled = gIndex === cat.groups.length - 1;
        downButton.addEventListener('click', () => {
          if(gIndex < cat.groups.length - 1) {
            [cat.groups[gIndex], cat.groups[gIndex + 1]] = [cat.groups[gIndex + 1], cat.groups[gIndex]];
            renderCategoryVideos(cat.id);
          }
        });
        controlDiv.appendChild(downButton);
        const removeButton = document.createElement('button');
        removeButton.innerHTML = "✖";
        removeButton.title = "Remove Group";
        removeButton.addEventListener('click', () => {
          cat.groups.splice(gIndex, 1);
          renderCategoryVideos(cat.id);
        });
        controlDiv.appendChild(removeButton);
        groupDiv.appendChild(controlDiv);
        const orderLabel = document.createElement('div');
        orderLabel.classList.add('orderLabel');
        orderLabel.textContent = `Group #${gIndex + 1}`;
        groupDiv.appendChild(orderLabel);
        group.forEach(video => {
          const videoPreview = document.createElement('div');
          if(video.link.includes('youtube.com') || video.link.includes('youtu.be')){
            const vidId = extractYouTubeId(video.link);
            if(vidId){
              const iframe = document.createElement('iframe');
              iframe.classList.add('youtubePreview');
              iframe.src = `https://www.youtube.com/embed/${vidId}?rel=0&modestbranding=1`;
              iframe.frameBorder = 0;
              videoPreview.appendChild(iframe);
            }
          } else {
            const preview = document.createElement('video');
            preview.classList.add('videoPreview');
            preview.src = video.link;
            preview.controls = true;
            videoPreview.appendChild(preview);
          }
          groupDiv.appendChild(videoPreview);
          const controls = document.createElement('div');
          controls.classList.add('controls');
          const timeInputs = document.createElement('div');
          timeInputs.classList.add('timeInputs');
          const startLabel = document.createElement('span');
          startLabel.textContent = 'Start Time:';
          timeInputs.appendChild(startLabel);
          const startDiv = createTimeDiv(getTimeString(video.startTimeDiv), () => { updateCategoryRawText(cat); });
          video.startTimeDiv = startDiv;
          timeInputs.appendChild(startDiv);
          const endLabel = document.createElement('span');
          endLabel.textContent = 'End Time:';
          timeInputs.appendChild(endLabel);
          const endDiv = createTimeDiv(getTimeString(video.endTimeDiv), () => { updateCategoryRawText(cat); });
          video.endTimeDiv = endDiv;
          timeInputs.appendChild(endDiv);
          controls.appendChild(timeInputs);
          groupDiv.appendChild(controls);
        });
        container.appendChild(groupDiv);
      });
    }

    
    function addCategory() {
      const newCat = {
        id: "cat_" + Date.now(),
        title: "New Category",
        rawText: "",
        groups: [],
        fileInput: null,
        txtFileInput: null,
        folderInput: null
      };
      categories.push(newCat);
      renderCategories();
    }
    function downloadCategory(cat) {
      let content = "Title: " + cat.title + "\n";
      if(cat.groups && cat.groups.length > 0){
        cat.groups.forEach(group => {
          const groupText = group.map(video => {
            const start = getTimeString(video.startTimeDiv);
            const end = getTimeString(video.endTimeDiv);
            if(start !== "00:00:00" || end !== "00:00:00"){
              return video.link + ", " + start + ", " + end;
            } else {
              return video.link;
            }
          }).join(" && ");
          content += groupText + "\n";
        });
      }
      const blob = new Blob([content], { type: 'text/plain' });
      const a = document.createElement('a');
      a.download = cat.title + ".txt";
      a.href = window.URL.createObjectURL(blob);
      a.click();
      window.URL.revokeObjectURL(a.href);
    }
    function downloadAllCategories() {
      let content = "";
      categories.forEach(cat => {
        content += "Title: " + cat.title + "\n";
        if(cat.groups && cat.groups.length > 0){
          cat.groups.forEach(group => {
            const groupText = group.map(video => {
              const start = getTimeString(video.startTimeDiv);
              const end = getTimeString(video.endTimeDiv);
              if(start !== "00:00:00" || end !== "00:00:00"){
                return video.link + ", " + start + ", " + end;
              } else {
                return video.link;
              }
            }).join(" && ");
            content += groupText + "\n";
          });
        }
        content += "\n";
      });
      const blob = new Blob([content], { type: 'text/plain' });
      const a = document.createElement('a');
      a.download = "all_categories.txt";
      a.href = window.URL.createObjectURL(blob);
      a.click();
      window.URL.revokeObjectURL(a.href);
    }
    function shuffleCategories() {
      for(let i = categories.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [categories[i], categories[j]] = [categories[j], categories[i]];
      }
      renderCategories();
    }
    function shuffleVideosInCategories() {
      categories.forEach(cat => {
        if(cat.groups && cat.groups.length > 1){
          for(let i = cat.groups.length - 1; i > 0; i--){
            const j = Math.floor(Math.random() * (i + 1));
            [cat.groups[i], cat.groups[j]] = [cat.groups[j], cat.groups[i]];
          }
          renderCategoryVideos(cat.id);
        }
      });
    }

    
    function buildGlobalPlaylist() {
      globalPlaylist = [];
      let maxGroups = 0;
      categories.forEach(cat => {
        if(cat.groups) {
          maxGroups = Math.max(maxGroups, cat.groups.length);
        }
      });
      for(let round = 0; round < maxGroups; round++){
        categories.forEach(cat => {
          if(cat.groups && cat.groups.length > 0){
            const group = cat.groups[round % cat.groups.length];
            globalPlaylist.push({ catId: cat.id, group: group });
          }
        });
      }
    }
    function playGlobalGroup(item, resetGroupIndex = true) {
      if(resetGroupIndex) { currentGroupVideoIndex = 0; }
      playVideoInGroup(item);
    }
    function playVideoInGroup(item) {
      const videoData = item.group[currentGroupVideoIndex];
      videoData.startTime = calculateSeconds(videoData.startTimeDiv);
      videoData.endTime = calculateSeconds(videoData.endTimeDiv);
      if(hls){ hls.destroy(); hls = null; }
      if(youtubePlayer && youtubePlayer.destroy){ youtubePlayer.destroy(); youtubePlayer = null; }
      const videoPlayer = document.getElementById('videoPlayer');
      const ytContainer = document.getElementById('youtubePlayerContainer');
      videoPlayer.pause();
      videoPlayer.style.display = 'none';
      if(videoData.link.includes('youtube.com') || videoData.link.includes('youtu.be')){
        const vidId = extractYouTubeId(videoData.link);
        ytContainer.style.display = 'block';
        ytContainer.innerHTML = "";
        const newDiv = document.createElement('div');
        newDiv.id = "ytPlayer";
        ytContainer.appendChild(newDiv);
        youtubePlayer = new YT.Player('ytPlayer', {
          height: '360',
          width: '100%',
          videoId: vidId,
          playerVars: {
            autoplay: 1,
            controls: minimalMode ? 0 : 1,
            modestbranding: 1,
            rel: 0,
            fs: minimalMode ? 0 : 1,
            iv_load_policy: minimalMode ? 3 : 1,
            disablekb: minimalMode ? 1 : 0,
            playsinline: 1,
            showinfo: minimalMode ? 0 : 1
          },
          events: {
            onReady: event => {
              const options = { videoId: vidId, startSeconds: videoData.startTime };
              if(videoData.endTime && videoData.endTime > 0){
                options.endSeconds = videoData.endTime;
              }
              event.target.loadVideoById(options);
              if(minimalMode){
                if(ytPollInterval) clearInterval(ytPollInterval);
                ytPollInterval = setInterval(() => {
                  const dur = event.target.getDuration();
                  const curr = event.target.getCurrentTime();
                  if(dur && (dur - curr < 0.5)){
                    clearInterval(ytPollInterval);
                    advanceAfterVideo(item);
                  }
                }, 500);
              }
            },
            onStateChange: event => {
              if(event.data === YT.PlayerState.ENDED){
                if(ytPollInterval) clearInterval(ytPollInterval);
                advanceAfterVideo(item);
              }
            }
          }
        });
      } else {
        ytContainer.style.display = 'none';
        videoPlayer.style.display = 'block';
        videoPlayer.controls = !minimalMode;
        if(videoData.link.endsWith('.m3u8')){
          hls = new Hls();
          hls.loadSource(videoData.link);
          hls.attachMedia(videoPlayer);
          hls.on(Hls.Events.MANIFEST_PARSED, () => {
            videoPlayer.currentTime = videoData.startTime || 0;
            videoPlayer.play();
          });
        } else {
          videoPlayer.src = videoData.link;
          videoPlayer.currentTime = videoData.startTime || 0;
          videoPlayer.play();
        }
        if(videoData.endTime && videoData.endTime > 0){
          videoPlayer.ontimeupdate = () => {
            if(videoPlayer.currentTime >= videoData.endTime){
              videoPlayer.pause();
              videoPlayer.ontimeupdate = null;
              advanceAfterVideo(item);
            }
          };
          videoPlayer.onended = null;
        } else {
          videoPlayer.onended = () => {
            advanceAfterVideo(item);
          };
        }
      }
    }
    function advanceAfterVideo(item) {
      if(currentGroupVideoIndex < item.group.length - 1){
        currentGroupVideoIndex++;
        playVideoInGroup(item);
      } else {
        currentGlobalIndex = (currentGlobalIndex + 1) % globalPlaylist.length;
        currentGroupVideoIndex = 0;
        playGlobalVideo();
      }
    }
    function playGlobalVideo() {
      if(globalPlaylist.length === 0) return;
      if(currentGlobalIndex >= globalPlaylist.length){
        currentGlobalIndex = 0;
      }
      playGlobalGroup(globalPlaylist[currentGlobalIndex], true);
    }
    function playNextGlobal() {
      const currentItem = globalPlaylist[currentGlobalIndex];
      if(currentGroupVideoIndex < currentItem.group.length - 1){
        currentGroupVideoIndex++;
        playVideoInGroup(currentItem);
      } else {
        currentGlobalIndex = (currentGlobalIndex + 1) % globalPlaylist.length;
        currentGroupVideoIndex = 0;
        playGlobalVideo();
      }
    }
    function playPreviousGlobal() {
      const currentItem = globalPlaylist[currentGlobalIndex];
      if(currentGroupVideoIndex > 0){
        currentGroupVideoIndex--;
        playVideoInGroup(currentItem);
      } else {
        currentGlobalIndex = currentGlobalIndex === 0 ? globalPlaylist.length - 1 : currentGlobalIndex - 1;
        const prevItem = globalPlaylist[currentGlobalIndex];
        currentGroupVideoIndex = prevItem.group.length - 1;
        playGlobalGroup(prevItem, false);
      }
    }
    function restartGlobalPlaylist() {
      currentGlobalIndex = 0;
      currentGroupVideoIndex = 0;
      playGlobalVideo();
    }

    
    document.getElementById('generatePlaylistButton').addEventListener('click', () => {
      buildGlobalPlaylist();
      currentGlobalIndex = 0;
      currentGroupVideoIndex = 0;
      playGlobalVideo();
      document.querySelector('.playlistControls').style.display = 'flex';
      document.getElementById('emptyMessage').style.display = 'none';
    });
    document.getElementById('nextButton').addEventListener('click', playNextGlobal);
    document.getElementById('prevButton').addEventListener('click', playPreviousGlobal);
    document.getElementById('restartButton').addEventListener('click', restartGlobalPlaylist);
    document.getElementById('fullscreenButton').addEventListener('click', () => {
      const elem = document.getElementById('videoPlayerContainer');
      if(!document.fullscreenElement){
        elem.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });
    
    document.getElementById('hideUIButton').addEventListener('click', () => {
      minimalMode = !minimalMode;
      const btn = document.getElementById('hideUIButton');
      btn.textContent = minimalMode ? "Normal UI" : "Minimal UI";
      const videoPlayer = document.getElementById('videoPlayer');
      if(videoPlayer) videoPlayer.controls = !minimalMode;
      if(youtubePlayer){
        let currentTime = youtubePlayer.getCurrentTime();
        const currentItem = globalPlaylist[currentGlobalIndex];
        const vidId = extractYouTubeId(currentItem.group[currentGroupVideoIndex].link);
        youtubePlayer.destroy();
        youtubePlayer = null;
        const ytContainer = document.getElementById('youtubePlayerContainer');
        ytContainer.innerHTML = "";
        const newDiv = document.createElement('div');
        newDiv.id = "ytPlayer";
        ytContainer.appendChild(newDiv);
        youtubePlayer = new YT.Player('ytPlayer', {
          height: '360',
          width: '100%',
          videoId: vidId,
          playerVars: {
            autoplay: 1,
            controls: minimalMode ? 0 : 1,
            modestbranding: 1,
            rel: 0,
            fs: minimalMode ? 0 : 1,
            iv_load_policy: minimalMode ? 3 : 1,
            disablekb: minimalMode ? 1 : 0,
            playsinline: 1,
            showinfo: minimalMode ? 0 : 1
          },
          events: {
            onReady: event => {
              const options = { videoId: vidId, startSeconds: currentTime };
              if(currentItem.group[currentGroupVideoIndex].endTime && currentItem.group[currentGroupVideoIndex].endTime > 0){
                options.endSeconds = currentItem.group[currentGroupVideoIndex].endTime;
              }
              event.target.loadVideoById(options);
            },
            onStateChange: event => {
              if(event.data === YT.PlayerState.ENDED){
                advanceAfterVideo(currentItem);
              }
            }
          }
        });
      }
    });

    
    document.getElementById('addCategoryButton').addEventListener('click', addCategory);
    document.getElementById('shuffleCategoriesButton').addEventListener('click', () => {
      for(let i = categories.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [categories[i], categories[j]] = [categories[j], categories[i]];
      }
      renderCategories();
    });
    document.getElementById('downloadAllButton').addEventListener('click', downloadAllCategories);
    
    document.getElementById('importAllTxtButton').addEventListener('click', () => {
      document.getElementById('globalTxtInput').click();
    });
    document.getElementById('shuffleVideosButton').addEventListener('click', shuffleVideosInCategories);
    
    document.getElementById('globalFolderImportBtn').addEventListener('click', () => {
      document.getElementById('globalFolderInput').click();
    });

    
    document.getElementById('globalTxtInput').addEventListener('change', function(event) {
      const files = event.target.files;
      for(let i = 0; i < files.length; i++){
        const file = files[i];
        const reader = new FileReader();
        reader.onload = function(e) {
          const content = e.target.result;
          
          const lines = content.split("\n");
          let categoriesFromFile = [];
          let currentCategoryLines = [];
          let currentTitle = "";
          lines.forEach(line => {
            if(line.trim().startsWith("Title:")){
              if(currentCategoryLines.length > 0){
                categoriesFromFile.push({ title: currentTitle || "Imported Category", rawText: currentCategoryLines.join("\n") });
                currentCategoryLines = [];
              }
              currentTitle = line.trim().substring(6).trim();
            } else {
              if(line.trim() !== ""){
                currentCategoryLines.push(line);
              }
            }
          });
          if(currentCategoryLines.length > 0){
            categoriesFromFile.push({ title: currentTitle || "Imported Category", rawText: currentCategoryLines.join("\n") });
          }
          categoriesFromFile.forEach(catData => {
            const newCat = {
              id: "cat_import_" + (importCatCounter++),
              title: catData.title,
              rawText: catData.rawText,
              groups: [],
              fileInput: null,
              txtFileInput: null,
              folderInput: null
            };
            parseCategory(newCat);
            categories.push(newCat);
          });
          renderCategories();
        };
        reader.readAsText(file);
      }
    });

    
    document.getElementById('globalFolderInput').addEventListener('change', function(event) {
      const files = Array.from(event.target.files);
      
      let videoMapping = {};
      files.forEach(f => {
        if(!f.name.toLowerCase().endsWith('.txt')){
          videoMapping[f.name] = URL.createObjectURL(f);
        }
      });
      
      let txtFiles = files.filter(f => f.name.toLowerCase().endsWith('.txt'));
      txtFiles.forEach(file => {
        const reader = new FileReader();
        reader.onload = function(e) {
          let content = e.target.result;
          
          const lines = content.split("\n").map(line => {
            const tokens = line.split(",");
            const newTokens = tokens.map(tok => {
              const ttrim = tok.trim();
              return videoMapping[ttrim] ? videoMapping[ttrim] : ttrim;
            });
            return newTokens.join(", ");
          });
          content = lines.join("\n");
          
          const allLines = content.split("\n");
          let categoriesFromFolder = [];
          let currentCatLines = [];
          let currentCatTitle = "";
          allLines.forEach(line => {
            if(line.trim().startsWith("Title:")){
              if(currentCatLines.length > 0){
                categoriesFromFolder.push({ title: currentCatTitle || "Imported Category", rawText: currentCatLines.join("\n") });
                currentCatLines = [];
              }
              currentCatTitle = line.trim().substring(6).trim();
            } else {
              if(line.trim() !== ""){
                currentCatLines.push(line);
              }
            }
          });
          if(currentCatLines.length > 0){
            categoriesFromFolder.push({ title: currentCatTitle || "Imported Category", rawText: currentCatLines.join("\n") });
          }
          categoriesFromFolder.forEach(catData => {
            const newCat = {
              id: "cat_import_" + (importCatCounter++),
              title: catData.title,
              rawText: catData.rawText,
              groups: [],
              fileInput: null,
              txtFileInput: null,
              folderInput: null
            };
            parseCategory(newCat);
            categories.push(newCat);
          });
          renderCategories();
        };
        reader.readAsText(file);
      });
    });

    
    document.addEventListener("fullscreenchange", () => {
      const container = document.getElementById('videoPlayerContainer');
      if(document.fullscreenElement === container)
        container.classList.add('full');
      else
        container.classList.remove('full');
    });

    
    document.addEventListener('DOMContentLoaded', function () {
      const darkModeEnabled = localStorage.getItem('darkMode') === 'true';
      if(darkModeEnabled){
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeToggle').textContent = 'Light Mode';
      }
      document.getElementById('darkModeToggle').addEventListener('click', function () {
        document.body.classList.toggle('dark-mode');
        const isDark = document.body.classList.contains('dark-mode');
        localStorage.setItem('darkMode', isDark);
        this.textContent = isDark ? 'Light Mode' : 'Dark Mode';
      });
    });

    
    if(categories.length === 0) {
      addCategory();
    }
    function renderCategoriesAndVideos() {
      renderCategories();
    }
    renderCategoriesAndVideos();
  </script>
</body>
</html>
